"""
MT5 Backtester GUI - A graphical interface for running MT5 Strategy Tester.
"""
# pylint: disable=broad-exception-caught,attribute-defined-outside-init

import json
import os
import re
import sys
import threading
import calendar
from datetime import datetime
from tkinter import filedialog, messagebox
from typing import Dict, List, Tuple, Optional

import customtkinter as ctk

# Ensure proper import path
current_dir = os.path.dirname(os.path.abspath(__file__))
src_dir = os.path.dirname(current_dir)
if src_dir not in sys.path:
    sys.path.insert(0, src_dir)

from MT5.mt5_tester import MT5Backtester  # pylint: disable=wrong-import-position
from MT5.report_generator import generate_report  # pylint: disable=wrong-import-position


# === EA INPUT PARSER ===
def parse_ea_inputs(mq5_path: str) -> List[Tuple[str, str, str]]:
    """Parse an MQ5 file to extract input parameters."""
    inputs = []
    if not os.path.exists(mq5_path):
        return inputs

    encodings = ['utf-8', 'utf-16', 'utf-16-le', 'cp1252', 'latin-1']
    content = None
    for encoding in encodings:
        try:
            with open(mq5_path, 'r', encoding=encoding) as f:
                content = f.read()
            break
        except (UnicodeDecodeError, UnicodeError):
            continue

    if content is None:
        return inputs

    pattern = re.compile(
        r'^\s*input\s+[\w\s<>]+?\s+(\w+)\s*=\s*([^;/]+?)\s*;\s*(?://\s*(.+))?$',
        re.MULTILINE
    )

    enum_map = {'LOT_MODE_FIXED': '0', 'LOT_MODE_PERCENT': '1'}

    for match in pattern.finditer(content):
        var_name = match.group(1).strip()
        default_val = match.group(2).strip()
        comment = match.group(3)
        display_name = comment.strip() if comment else var_name

        if default_val.startswith('"') and default_val.endswith('"'):
            default_val = default_val[1:-1]
        if default_val in enum_map:
            default_val = enum_map[default_val]

        inputs.append((var_name, default_val, display_name))

    return inputs


def find_mq5_source(expert_path: str, data_path: str) -> Optional[str]:
    """Find the .mq5 source file for a given Expert Advisor."""
    if expert_path.lower().endswith('.ex5'):
        mq5_relative = expert_path[:-4] + '.mq5'
    else:
        mq5_relative = expert_path + '.mq5'

    possible_paths = [
        os.path.join(data_path, "MQL5", "Experts", mq5_relative),
        os.path.join(data_path, "MQL5", mq5_relative),
    ]

    if os.path.isabs(expert_path):
        base = expert_path[:-4] + '.mq5' if expert_path.lower().endswith('.ex5') else expert_path
        possible_paths.insert(0, base)

    for path in possible_paths:
        if os.path.exists(path):
            return path
    return None


# === SET FILE HANDLING ===
def parse_set_file(set_path: str) -> Dict[str, str]:
    """Parse an MT5 .set file to extract parameter values."""
    params = {}
    if not os.path.exists(set_path):
        return params

    encodings = ['utf-16', 'utf-16-le', 'utf-8', 'cp1252', 'latin-1']
    content = None
    for encoding in encodings:
        try:
            with open(set_path, 'r', encoding=encoding) as f:
                content = f.read()
            break
        except (UnicodeDecodeError, UnicodeError):
            continue

    if content is None:
        return params

    for line in content.splitlines():
        line = line.strip()
        if not line or line.startswith(';'):
            continue
        if '=' in line:
            key, value = line.split('=', 1)
            key, value = key.strip(), value.strip()
            if '||' in value:
                value = value.split('||')[0]
            params[key] = value

    return params


def save_set_file(set_path: str, params: Dict[str, str], comment: str = None):
    """Save parameters to an MT5 .set file."""
    lines = []
    if comment:
        lines.append(f"; {comment}")
    lines.append(f"; Generated by MBO MT5 Backtester")
    lines.append(f"; Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append("")
    for key, value in params.items():
        lines.append(f"{key}={value}")

    with open(set_path, 'w', encoding='utf-16') as f:
        f.write('\n'.join(lines))


# === WINDOW POSITION PERSISTENCE ===
WINDOW_POS_FILE = os.path.join(current_dir, ".window_position.json")
LAST_EA_VALUES_FILE = os.path.join(current_dir, ".last_ea_values.json")


def load_window_state():
    """Load saved window position."""
    try:
        with open(WINDOW_POS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}


def save_window_state(x, y, report_path=None):
    """Save window position."""
    try:
        data = load_window_state()
        data["x"], data["y"] = x, y
        if report_path:
            data["report_path"] = report_path
        with open(WINDOW_POS_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f)
    except (OSError, IOError):
        pass


def load_last_ea_values() -> Dict[str, Dict[str, str]]:
    """Load last used EA values."""
    try:
        with open(LAST_EA_VALUES_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}


def save_last_ea_values(expert_path: str, values: Dict[str, str]):
    """Save last used EA values."""
    try:
        data = load_last_ea_values()
        data[expert_path] = values
        with open(LAST_EA_VALUES_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except (OSError, IOError):
        pass


# === TRANSLATIONS ===
TRANSLATIONS = {
    "EN": {
        "window_title": "MT5 Backtester Runner",
        "main_title": "MT5 Strategy Tester Config",
        "terminal_settings": "Terminal Settings",
        "tester_settings": "Tester Settings",
        "output_settings": "Output Settings",
        "ea_inputs": "EA Inputs",
        "sorrend": "Sorrend",
        "terminal_path": "Terminal Path:",
        "expert_advisor": "Expert Advisor:",
        "symbol": "Symbol:",
        "period": "Period:",
        "from_date": "From Date:",
        "to_date": "To Date:",
        "model": "Model:",
        "execution_delay": "Execution Delay:",
        "deposit": "Deposit:",
        "currency": "Currency:",
        "leverage": "Leverage:",
        "visual_mode": "Visual Mode (0/1):",
        "report_path": "Report Path:",
        "ini_report_name": "INI/Report Name:",
        "sorrend_no": "No.:",
        "run_backtest": "RUN BACKTEST",
        "running": "Running...",
        "open_report": "Open Report",
        "close": "Close",
        "load_set": "Load",
        "save_set": "Save",
        "date_picker": "Date Picker",
        "today": "Today",
        "config_saved": "Config saved:",
        "backtest_running": "Backtest running...",
        "generating_report": "Generating Dark Theme report...",
        "report_generated": "Report generated!",
        "report_gen_failed": "Report gen failed:",
        "mt5_report_not_found": "MT5 report not found",
        "backtest_failed": "Backtest failed!",
        "check_mt5_logs": "Check MT5 logs.",
        "backtest_finished": "Backtest Finished",
        "backtest_completed": "Backtest Completed Successfully!",
        "report_saved_to": "Report saved to:",
        "error": "Error",
        "mt5_not_found": "MT5 terminal not found at:",
        "select_report_folder": "Please select a report output folder.",
        "failed_create_folder": "Failed to create folder:",
        "failed_create_config": "Failed to create config:",
        "report_not_found": "Report file not found.",
        "model_0": "0 - Every tick",
        "model_1": "1 - 1 minute OHLC",
        "model_2": "2 - Open prices only",
        "model_3": "3 - Math calculations",
        "model_4": "4 - Every tick (real)",
        "mon_tue": "Mon-Tue",
        "wed_fri": "Wed-Fri",
        "days": ["M", "T", "W", "T", "F", "S", "S"],
        "months": ["", "January", "February", "March", "April", "May", "June",
                   "July", "August", "September", "October", "November", "December"],
    },
    "HU": {
        "window_title": "MT5 Backtester Futtato",
        "main_title": "MT5 Strategy Tester Konfiguracio",
        "terminal_settings": "Terminal Beallitasok",
        "tester_settings": "Teszter Beallitasok",
        "output_settings": "Kimenet Beallitasok",
        "ea_inputs": "EA Bemenetek",
        "sorrend": "Sorrend",
        "terminal_path": "Terminal Utvonal:",
        "expert_advisor": "Expert Advisor:",
        "symbol": "Szimbolum:",
        "period": "Periodus:",
        "from_date": "Kezdo Datum:",
        "to_date": "Zaro Datum:",
        "model": "Modell:",
        "execution_delay": "Vegrehajtasi Kesleltetes:",
        "deposit": "Letet:",
        "currency": "Penznem:",
        "leverage": "TokeattÃ©tel:",
        "visual_mode": "Vizualis Mod (0/1):",
        "report_path": "Riport Utvonal:",
        "ini_report_name": "INI/Riport Nev:",
        "sorrend_no": "Szam:",
        "run_backtest": "BACKTEST INDITAS",
        "running": "Futas...",
        "open_report": "Riport Megnyitasa",
        "close": "Bezaras",
        "load_set": "Betoltes",
        "save_set": "Mentes",
        "date_picker": "Datum Valaszto",
        "today": "Ma",
        "config_saved": "Konfig mentve:",
        "backtest_running": "Backtest fut...",
        "generating_report": "Dark Theme riport generalasa...",
        "report_generated": "Riport elkeszult!",
        "report_gen_failed": "Riport generalas sikertelen:",
        "mt5_report_not_found": "MT5 riport nem talalhato",
        "backtest_failed": "Backtest sikertelen!",
        "check_mt5_logs": "Ellenorizd az MT5 logokat.",
        "backtest_finished": "Backtest Befejezve",
        "backtest_completed": "Backtest Sikeresen Befejezve!",
        "report_saved_to": "Riport mentve:",
        "error": "Hiba",
        "mt5_not_found": "MT5 terminal nem talalhato:",
        "select_report_folder": "Kerlek valassz ki egy riport mappat.",
        "failed_create_folder": "Mappa letrehozasa sikertelen:",
        "failed_create_config": "Konfig letrehozasa sikertelen:",
        "report_not_found": "Riport fajl nem talalhato.",
        "model_0": "0 - Minden tick",
        "model_1": "1 - 1 perces OHLC",
        "model_2": "2 - Csak nyito arak",
        "model_3": "3 - Matematikai szamitasok",
        "model_4": "4 - Minden tick (valos)",
        "mon_tue": "H-K",
        "wed_fri": "Sze-P",
        "days": ["H", "K", "Sze", "Cs", "P", "Szo", "V"],
        "months": ["", "Januar", "Februar", "Marcius", "Aprilis", "Majus", "Junius",
                   "Julius", "Augusztus", "Szeptember", "Oktober", "November", "December"],
    }
}


# === SORREND DATA ===
def load_sorrend_data():
    """Load sorrend data from JSON file."""
    sorrend_path = os.path.join(src_dir, "gui", "sorrend_data.json")
    try:
        with open(sorrend_path, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {"HK_DATA": {}, "SZP_DATA": {}}


def get_sorrend_settings(no: int, mode: str = "HK") -> str:
    """Get settings string for a given number and mode."""
    data = load_sorrend_data()
    str_no = str(no)
    if mode == "HK":
        return data.get("HK_DATA", {}).get(str_no, "")
    if mode == "SZP":
        return data.get("SZP_DATA", {}).get(str_no, "")
    return ""


class CalendarPopup(ctk.CTkToplevel):
    """Windows-style calendar date picker popup."""
    last_position: tuple = None

    def __init__(self, parent, callback, initial_date=None, lang="EN"):
        super().__init__(parent)
        self.callback = callback
        self.lang = lang
        self.tr = TRANSLATIONS[lang]
        self.title(self.tr["date_picker"])

        pos = CalendarPopup.last_position
        if pos is not None:
            self.geometry(f"280x320+{pos[0]}+{pos[1]}")
        else:
            self.geometry("280x320")
        self.resizable(False, False)
        self.bind("<Configure>", self._save_position)
        self.transient(parent)
        self.grab_set()

        if initial_date:
            try:
                parts = initial_date.replace("-", ".").split(".")
                self.current_year = int(parts[0])
                self.current_month = int(parts[1])
                self.selected_day = int(parts[2]) if len(parts) > 2 else 1
            except (ValueError, IndexError):
                now = datetime.now()
                self.current_year, self.current_month, self.selected_day = now.year, now.month, now.day
        else:
            now = datetime.now()
            self.current_year, self.current_month, self.selected_day = now.year, now.month, now.day

        self.day_buttons = []
        self._build_ui()

    def _build_ui(self):
        """Build the calendar UI."""
        header_frame = ctk.CTkFrame(self, fg_color="transparent")
        header_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkButton(header_frame, text="<<", width=30, command=self._prev_year).pack(side="left")
        ctk.CTkButton(header_frame, text="<", width=30, command=self._prev_month).pack(side="left", padx=2)

        self.month_year_label = ctk.CTkLabel(header_frame, text="", font=("Arial", 14, "bold"))
        self.month_year_label.pack(side="left", expand=True)

        ctk.CTkButton(header_frame, text=">", width=30, command=self._next_month).pack(side="right", padx=2)
        ctk.CTkButton(header_frame, text=">>", width=30, command=self._next_year).pack(side="right")

        days_frame = ctk.CTkFrame(self, fg_color="transparent")
        days_frame.pack(fill="x", padx=10)
        for day_name in self.tr["days"]:
            ctk.CTkLabel(days_frame, text=day_name, width=35, font=("Arial", 10, "bold"), text_color="cyan").pack(side="left", padx=1)

        self.calendar_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.calendar_frame.pack(fill="both", expand=True, padx=10, pady=5)

        ctk.CTkButton(self, text=self.tr["today"], width=60, command=self._select_today).pack(pady=10)
        self._update_calendar()

    def _update_calendar(self):
        """Update the calendar display."""
        month_name = self.tr["months"][self.current_month]
        self.month_year_label.configure(text=f"{self.current_year} {month_name}")

        for widget in self.calendar_frame.winfo_children():
            widget.destroy()
        self.day_buttons = []

        cal = calendar.Calendar(firstweekday=0)
        for week in cal.monthdayscalendar(self.current_year, self.current_month):
            week_frame = ctk.CTkFrame(self.calendar_frame, fg_color="transparent")
            week_frame.pack(fill="x")
            for day in week:
                if day == 0:
                    lbl = ctk.CTkLabel(week_frame, text="", width=35)
                    lbl.pack(side="left", padx=1, pady=1)
                else:
                    is_selected = day == self.selected_day
                    btn = ctk.CTkButton(
                        week_frame, text=str(day), width=35, height=28,
                        fg_color="green" if is_selected else "gray30",
                        hover_color="darkgreen" if is_selected else "gray40",
                        command=lambda d=day: self._select_day(d)
                    )
                    btn.pack(side="left", padx=1, pady=1)
                    self.day_buttons.append(btn)

    def _prev_year(self):
        self.current_year -= 1
        self._update_calendar()

    def _next_year(self):
        self.current_year += 1
        self._update_calendar()

    def _prev_month(self):
        self.current_month -= 1
        if self.current_month < 1:
            self.current_month = 12
            self.current_year -= 1
        self._update_calendar()

    def _next_month(self):
        self.current_month += 1
        if self.current_month > 12:
            self.current_month = 1
            self.current_year += 1
        self._update_calendar()

    def _select_today(self):
        now = datetime.now()
        self.current_year, self.current_month = now.year, now.month
        self._select_day(now.day)

    def _save_position(self, _event=None):
        if self.winfo_exists() and self.winfo_viewable():
            CalendarPopup.last_position = (self.winfo_x(), self.winfo_y())

    def _select_day(self, day):
        self._save_position()
        self.callback(f"{self.current_year}.{self.current_month:02d}.{day:02d}")
        self.destroy()


class MT5TesterApp(ctk.CTk):
    """Main application window for MT5 Backtester."""
    LEFT_COLUMN_WIDTH = 420
    RIGHT_COLUMN_WIDTH = 420

    def __init__(self):
        super().__init__()
        self.current_lang = "EN"
        self.tr = TRANSLATIONS[self.current_lang]
        self.title(self.tr["window_title"])

        self.window_width, self.window_height = 900, 850
        self.saved_state = load_window_state()
        if self.saved_state.get("x") and self.saved_state.get("y"):
            self.geometry(f"{self.window_width}x{self.window_height}+{self.saved_state['x']}+{self.saved_state['y']}")
        else:
            self.geometry(f"{self.window_width}x{self.window_height}")

        self.resizable(False, False)
        self.protocol("WM_DELETE_WINDOW", self._on_closing)

        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("blue")

        self.tester = MT5Backtester()
        self.report_path = None
        self.entries = {}
        self.dropdowns = {}
        self.input_entries = {}
        self.report_path_entry = None
        self.terminal_path_entry = None
        self.status_label = None
        self.btn_run = None
        self._output_folder = None
        self._report_name = None
        self.trading_days_mode = False
        self.labels = {}
        self.section_headers = {}

        self._setup_ui()

    def _on_closing(self):
        report_path = self.report_path_entry.get().strip() if self.report_path_entry else None
        save_window_state(self.winfo_x(), self.winfo_y(), report_path)
        self._save_current_ea_values()
        self.destroy()

    def _get_model_options(self):
        return [self.tr[f"model_{i}"] for i in range(5)]

    def _setup_ui(self):
        """Set up the user interface."""
        # Top bar
        top_bar = ctk.CTkFrame(self, fg_color="transparent")
        top_bar.pack(fill="x", padx=15, pady=(10, 0))

        lang_frame = ctk.CTkFrame(top_bar, fg_color="transparent")
        lang_frame.pack(side="right")

        self.lang_label_en = ctk.CTkLabel(lang_frame, text="EN", font=("Arial", 11, "bold"), text_color="white")
        self.lang_label_en.pack(side="left", padx=(0, 5))
        self.lang_switch = ctk.CTkSwitch(lang_frame, text="", command=self._on_language_change, width=40)
        self.lang_switch.pack(side="left")
        self.lang_label_hu = ctk.CTkLabel(lang_frame, text="HU", font=("Arial", 11, "bold"), text_color="gray")
        self.lang_label_hu.pack(side="left", padx=(5, 0))

        self.title_label = ctk.CTkLabel(top_bar, text=self.tr["main_title"], font=("Arial", 22, "bold"))
        self.title_label.pack(side="left", expand=True)

        # Bottom frame
        bottom_frame = ctk.CTkFrame(self, fg_color="transparent")
        bottom_frame.pack(side="bottom", fill="x", padx=15, pady=10)

        self.status_label = ctk.CTkLabel(bottom_frame, text="", text_color="gray")
        self.status_label.pack(pady=5)

        self.btn_run = ctk.CTkButton(
            bottom_frame, text=self.tr["run_backtest"], font=("Arial", 16, "bold"),
            height=50, fg_color="green", hover_color="darkgreen", command=self.run_process
        )
        self.btn_run.pack(fill="x")

        # Main content
        main_frame = ctk.CTkFrame(self, fg_color="transparent")
        main_frame.pack(fill="both", expand=True, padx=15, pady=5)

        left_frame = ctk.CTkFrame(main_frame, width=self.LEFT_COLUMN_WIDTH)
        left_frame.pack(side="left", fill="y", padx=(0, 10))
        left_frame.pack_propagate(False)

        right_frame = ctk.CTkFrame(main_frame, width=self.RIGHT_COLUMN_WIDTH)
        right_frame.pack(side="right", fill="y", padx=(10, 0))
        right_frame.pack_propagate(False)

        self._setup_left_column(left_frame)
        self._setup_right_column(right_frame)

    def _on_language_change(self):
        if self.lang_switch.get():
            self.current_lang = "HU"
            self.lang_label_hu.configure(text_color="white")
            self.lang_label_en.configure(text_color="gray")
        else:
            self.current_lang = "EN"
            self.lang_label_en.configure(text_color="white")
            self.lang_label_hu.configure(text_color="gray")
        self.tr = TRANSLATIONS[self.current_lang]
        self._update_all_texts()

    def _update_all_texts(self):
        self.title(self.tr["window_title"])
        self.title_label.configure(text=self.tr["main_title"])
        self.btn_run.configure(text=self.tr["run_backtest"])
        for key, lbl in self.section_headers.items():
            lbl.configure(text=self.tr.get(key, key))
        for key, lbl in self.labels.items():
            lbl.configure(text=self.tr.get(key, key))
        self.label_hk.configure(text=self.tr["mon_tue"])
        self.label_szp.configure(text=self.tr["wed_fri"])
        if hasattr(self, 'btn_load_set'):
            self.btn_load_set.configure(text=self.tr["load_set"])
        if hasattr(self, 'btn_save_set'):
            self.btn_save_set.configure(text=self.tr["save_set"])
        if 'Model' in self.dropdowns:
            current_idx = 0
            current_val = self.dropdowns['Model'].get()
            for i, _ in enumerate(self._get_model_options()):
                if current_val.startswith(str(i)):
                    current_idx = i
                    break
            self.dropdowns['Model'].configure(values=self._get_model_options())
            self.dropdowns['Model'].set(self._get_model_options()[current_idx])

    def _setup_left_column(self, parent):
        self.section_headers["terminal_settings"] = self._add_section_header(parent, self.tr["terminal_settings"])
        self.terminal_path_entry, self.labels["terminal_path"] = self._add_input_row(
            parent, self.tr["terminal_path"], r"C:\Program Files\MetaTrader 5.3\terminal64.exe", "terminal_path"
        )

        self.section_headers["tester_settings"] = self._add_section_header(parent, self.tr["tester_settings"])
        self.entries['Expert'], self.labels["expert_advisor"] = self._add_input_row(
            parent, self.tr["expert_advisor"], r"Advisors\MT5_MBO_V3.ex5", "expert_advisor"
        )
        self.entries['Expert'].bind("<FocusOut>", lambda e: self._refresh_ea_inputs())

        self.entries['Symbol'], self.labels["symbol"] = self._add_input_row(parent, self.tr["symbol"], "EURJPY_T", "symbol")
        self.entries['Period'], self.labels["period"] = self._add_input_row(parent, self.tr["period"], "M1", "period")
        self.entries['FromDate'], self.labels["from_date"] = self._add_date_row(parent, self.tr["from_date"], "2024.01.07", "from_date")
        self.entries['ToDate'], self.labels["to_date"] = self._add_date_row(parent, self.tr["to_date"], "2024.12.28", "to_date")
        self.dropdowns['Model'], self.labels["model"] = self._add_dropdown_row(parent, self.tr["model"], self._get_model_options(), 0, "model")
        self.entries['ExecutionMode'], self.labels["execution_delay"] = self._add_input_row(parent, self.tr["execution_delay"], "50", "execution_delay")
        self.entries['Deposit'], self.labels["deposit"] = self._add_input_row(parent, self.tr["deposit"], "100000", "deposit")
        self.entries['Currency'], self.labels["currency"] = self._add_input_row(parent, self.tr["currency"], "USD", "currency")
        self.entries['Leverage'], self.labels["leverage"] = self._add_input_row(parent, self.tr["leverage"], "1:500", "leverage")
        self.entries['Visual'], self.labels["visual_mode"] = self._add_input_row(parent, self.tr["visual_mode"], "0", "visual_mode")

        self.section_headers["output_settings"] = self._add_section_header(parent, self.tr["output_settings"])
        self._setup_report_path_row(parent)
        self.ini_name_entry, self.labels["ini_report_name"] = self._add_input_row(parent, self.tr["ini_report_name"], "test", "ini_report_name")

    def _setup_right_column(self, parent):
        self.section_headers["sorrend"] = self._add_section_header(parent, self.tr["sorrend"])

        trading_frame = ctk.CTkFrame(parent, fg_color="transparent")
        trading_frame.pack(fill="x", pady=5, padx=10)

        self.label_hk = ctk.CTkLabel(trading_frame, text=self.tr["mon_tue"], font=("Arial", 12, "bold"), text_color="white", width=60, anchor="e")
        self.label_hk.pack(side="left", padx=(0, 8))
        self.switch_trading_days = ctk.CTkSwitch(trading_frame, text="", command=self._on_trading_days_change, width=50)
        self.switch_trading_days.pack(side="left")
        self.label_szp = ctk.CTkLabel(trading_frame, text=self.tr["wed_fri"], font=("Arial", 12, "bold"), text_color="gray", width=60, anchor="w")
        self.label_szp.pack(side="left", padx=(8, 0))

        sorrend_frame = ctk.CTkFrame(parent, fg_color="transparent")
        sorrend_frame.pack(fill="x", pady=5, padx=10)

        self.labels["sorrend_no"] = ctk.CTkLabel(sorrend_frame, text=self.tr["sorrend_no"], width=40, anchor="w")
        self.labels["sorrend_no"].pack(side="left")
        self.sorrend_entry = ctk.CTkEntry(sorrend_frame, width=70)
        self.sorrend_entry.insert(0, "0")
        self.sorrend_entry.pack(side="left", padx=(0, 10))
        self.sorrend_entry.bind("<KeyRelease>", self._on_sorrend_change)
        self.sorrend_result = ctk.CTkLabel(sorrend_frame, text="(...)", text_color="yellow", font=("Arial", 13, "bold"))
        self.sorrend_result.pack(side="left", expand=True, fill="x")

        # EA Inputs section
        ea_header_frame = ctk.CTkFrame(parent, fg_color="transparent")
        ea_header_frame.pack(fill="x", pady=(15, 8), padx=10)

        self.section_headers["ea_inputs"] = ctk.CTkLabel(ea_header_frame, text=self.tr["ea_inputs"], font=("Arial", 14, "bold"), text_color="cyan")
        self.section_headers["ea_inputs"].pack(side="left")

        ea_buttons_frame = ctk.CTkFrame(ea_header_frame, fg_color="transparent")
        ea_buttons_frame.pack(side="right")

        self.btn_load_set = ctk.CTkButton(ea_buttons_frame, text=self.tr["load_set"], width=55, height=24, font=("Arial", 11), fg_color="gray30", command=self._load_set_file)
        self.btn_load_set.pack(side="left", padx=(0, 5))
        self.btn_save_set = ctk.CTkButton(ea_buttons_frame, text=self.tr["save_set"], width=55, height=24, font=("Arial", 11), fg_color="gray30", command=self._save_set_file)
        self.btn_save_set.pack(side="left", padx=(0, 5))
        ctk.CTkButton(ea_buttons_frame, text="â†»", width=30, height=24, font=("Arial", 14), command=self._refresh_ea_inputs).pack(side="left")

        self.ea_inputs_container = ctk.CTkFrame(parent, fg_color="transparent")
        self.ea_inputs_container.pack(fill="both", expand=True, padx=0, pady=0)
        self.ea_input_widgets = {}
        self._refresh_ea_inputs()

    def _refresh_ea_inputs(self):
        for widget in self.ea_inputs_container.winfo_children():
            widget.destroy()
        self.ea_input_widgets.clear()
        self.input_entries.clear()

        expert_path = self.entries.get('Expert')
        expert_path = expert_path.get().strip() if expert_path else ""

        default_inputs = [
            ("InpLotMode", "1", "Lot mÃ©retezÃ©si mÃ³d"),
            ("InpFixedLot", "5", "Fix lot mÃ©ret"),
            ("prots", "1.0", "Percent"),
            ("magic_inp", "12345", "Magic"),
            ("start_cand_monitor_1", "3", "Starting candle 1"),
            ("end_cand_monitor_1", "4", "Starting point 1"),
            ("closing_can_1", "117", "Closing candle 1"),
            ("open_offset_1", "300", "High/low price offset 1"),
            ("open_direction_1", "4", "Positions 1"),
            ("start_cand_monitor_2", "-1", "Starting candle 2"),
            ("end_cand_monitor_2", "55", "Starting point 2"),
            ("closing_can_2", "117", "Closing candle 2"),
            ("open_offset_2", "100", "High/low price offset 2"),
            ("open_direction_2", "1", "Positions 2")
        ]

        ea_inputs = []
        mq5_path = find_mq5_source(expert_path, self.tester.data_path)
        if mq5_path:
            parsed = parse_ea_inputs(mq5_path)
            if parsed:
                ea_inputs = parsed
                self._update_status(f"EA inputs loaded from: {os.path.basename(mq5_path)}", "green")

        if not ea_inputs:
            ea_inputs = default_inputs
            if expert_path:
                self._update_status("EA source (.mq5) not found, using defaults", "yellow")

        last_values = {}
        if expert_path:
            last_values = load_last_ea_values().get(expert_path, {})

        for var_name, default_val, display_name in ea_inputs:
            value = last_values.get(var_name, default_val)
            entry, lbl, frame = self._add_ea_input_row(self.ea_inputs_container, var_name, value, display_name)
            self.ea_input_widgets[var_name] = (entry, lbl, frame)
            self.input_entries[var_name] = entry

    def _get_current_ea_values(self) -> Dict[str, str]:
        return {var_name: entry.get().strip() for var_name, entry in self.input_entries.items()}

    def _set_ea_values(self, values: Dict[str, str]):
        for var_name, value in values.items():
            if var_name in self.input_entries:
                entry = self.input_entries[var_name]
                entry.delete(0, "end")
                entry.insert(0, str(value))

    def _save_current_ea_values(self):
        expert_path = self.entries.get('Expert')
        if expert_path:
            expert_path = expert_path.get().strip()
            if expert_path:
                save_last_ea_values(expert_path, self._get_current_ea_values())

    def _load_set_file(self):
        initial_dir = os.path.join(self.tester.data_path, "MQL5", "Profiles", "Tester")
        if not os.path.exists(initial_dir):
            initial_dir = os.path.expanduser("~")

        filepath = filedialog.askopenfilename(
            title="Load EA Settings", initialdir=initial_dir,
            filetypes=[("MT5 Settings", "*.set"), ("All files", "*.*")]
        )
        if filepath:
            params = parse_set_file(filepath)
            if params:
                self._set_ea_values(params)
                self._update_status(f"Loaded: {os.path.basename(filepath)}", "green")
            else:
                self._update_status("Failed to load .set file", "red")

    def _save_set_file(self):
        initial_dir = os.path.join(self.tester.data_path, "MQL5", "Profiles", "Tester")
        if not os.path.exists(initial_dir):
            try:
                os.makedirs(initial_dir)
            except OSError:
                initial_dir = os.path.expanduser("~")

        expert_path = self.entries.get('Expert')
        if expert_path:
            expert_name = os.path.splitext(os.path.basename(expert_path.get().strip()))[0]
        else:
            expert_name = "settings"

        filepath = filedialog.asksaveasfilename(
            title="Save EA Settings", initialdir=initial_dir, initialfile=f"{expert_name}.set",
            defaultextension=".set", filetypes=[("MT5 Settings", "*.set"), ("All files", "*.*")]
        )
        if filepath:
            save_set_file(filepath, self._get_current_ea_values(), comment=expert_name)
            self._update_status(f"Saved: {os.path.basename(filepath)}", "green")

    def _on_trading_days_change(self):
        if self.switch_trading_days.get():
            self.trading_days_mode = True
            self.label_szp.configure(text_color="white")
            self.label_hk.configure(text_color="gray")
        else:
            self.trading_days_mode = False
            self.label_hk.configure(text_color="white")
            self.label_szp.configure(text_color="gray")
        self._on_sorrend_change()

    def _on_sorrend_change(self, _event=None):
        text = self.sorrend_entry.get().strip()
        if not text or not text.isdigit():
            self.sorrend_result.configure(text="(...)")
            return

        try:
            no = int(text)
            if no < 0 or no > 6143:
                self.sorrend_result.configure(text="(0-6143)")
                return

            mode = "SZP" if self.trading_days_mode else "HK"
            settings = get_sorrend_settings(no, mode)

            if settings:
                display = settings[:40] + "..." if len(settings) > 40 else settings
                self.sorrend_result.configure(text=f"({display})")
            else:
                self.sorrend_result.configure(text="(not found)")
        except ValueError:
            self.sorrend_result.configure(text="(...)")

    def _add_section_header(self, parent, text):
        lbl = ctk.CTkLabel(parent, text=text, font=("Arial", 14, "bold"), text_color="cyan")
        lbl.pack(pady=(15, 8), padx=10, anchor="w")
        return lbl

    def _add_input_row(self, parent, label_text, default_value, label_key=None):
        _ = label_key
        frame = ctk.CTkFrame(parent, fg_color="transparent")
        frame.pack(fill="x", pady=2, padx=10)
        lbl = ctk.CTkLabel(frame, text=label_text, width=150, anchor="w")
        lbl.pack(side="left")
        entry = ctk.CTkEntry(frame)
        entry.insert(0, str(default_value))
        entry.pack(side="right", expand=True, fill="x")
        return entry, lbl

    def _add_ea_input_row(self, parent, var_name, default_value, display_name):
        frame = ctk.CTkFrame(parent, fg_color="transparent")
        frame.pack(fill="x", pady=1, padx=10)
        lbl = ctk.CTkLabel(frame, text=display_name, width=280, anchor="w", font=("Arial", 11))
        lbl.pack(side="left")
        entry = ctk.CTkEntry(frame, width=80, justify="center")
        entry.insert(0, str(default_value))
        entry.pack(side="right")
        return entry, lbl, frame

    def _add_date_row(self, parent, label_text, default_value, label_key=None):
        _ = label_key
        frame = ctk.CTkFrame(parent, fg_color="transparent")
        frame.pack(fill="x", pady=2, padx=10)
        lbl = ctk.CTkLabel(frame, text=label_text, width=150, anchor="w")
        lbl.pack(side="left")
        entry = ctk.CTkEntry(frame)
        entry.insert(0, str(default_value))
        entry.pack(side="left", expand=True, fill="x", padx=(0, 5))
        ctk.CTkButton(frame, text="ðŸ“…", width=35, command=lambda e=entry: self._open_calendar(e)).pack(side="right")
        return entry, lbl

    def _add_dropdown_row(self, parent, label_text, options, default_index=0, label_key=None):
        _ = label_key
        frame = ctk.CTkFrame(parent, fg_color="transparent")
        frame.pack(fill="x", pady=2, padx=10)
        lbl = ctk.CTkLabel(frame, text=label_text, width=150, anchor="w")
        lbl.pack(side="left")
        dropdown = ctk.CTkComboBox(frame, values=options, state="readonly", width=200)
        dropdown.set(options[default_index])
        dropdown.pack(side="right", expand=True, fill="x")
        return dropdown, lbl

    def _open_calendar(self, entry_widget):
        current_date = entry_widget.get().strip()

        def on_date_selected(date_str):
            entry_widget.delete(0, "end")
            entry_widget.insert(0, date_str)

        CalendarPopup(self, on_date_selected, current_date, self.current_lang)

    def _setup_report_path_row(self, parent):
        frame = ctk.CTkFrame(parent, fg_color="transparent")
        frame.pack(fill="x", pady=2, padx=10)
        self.labels["report_path"] = ctk.CTkLabel(frame, text=self.tr["report_path"], width=150, anchor="w")
        self.labels["report_path"].pack(side="left")

        self.report_path_entry = ctk.CTkEntry(frame)
        saved_path = self.saved_state.get("report_path", "")
        if saved_path and os.path.exists(os.path.dirname(saved_path) or saved_path):
            default_path = saved_path
        else:
            default_path = os.path.join(os.path.expanduser("~"), "Documents", "MT5_Reports")
        self.report_path_entry.insert(0, default_path)
        self.report_path_entry.pack(side="left", expand=True, fill="x", padx=(0, 5))

        ctk.CTkButton(frame, text="...", width=35, command=self._browse_report_path).pack(side="right")

    def _update_status(self, text, color="gray"):
        self.status_label.configure(text=text, text_color=color)

    def _browse_report_path(self):
        folder = filedialog.askdirectory(title="Select Report Output Folder", initialdir=self.report_path_entry.get() or os.path.expanduser("~"))
        if folder:
            self.report_path_entry.delete(0, "end")
            self.report_path_entry.insert(0, folder)

    def run_process(self):
        terminal_path = self.terminal_path_entry.get().strip()
        if terminal_path:
            self.tester.terminal_path = terminal_path

        if not os.path.exists(self.tester.terminal_path):
            messagebox.showerror(self.tr["error"], f"{self.tr['mt5_not_found']}\n{self.tester.terminal_path}")
            return

        params = self._gather_params()
        report_folder = self.report_path_entry.get().strip()
        if not report_folder:
            messagebox.showerror(self.tr["error"], self.tr["select_report_folder"])
            return

        if not os.path.exists(report_folder):
            try:
                os.makedirs(report_folder)
            except OSError as e:
                messagebox.showerror(self.tr["error"], f"{self.tr['failed_create_folder']} {e}")
                return

        base_name = self.ini_name_entry.get().strip() or "test"
        report_filename = base_name
        counter = 1
        while os.path.exists(os.path.join(report_folder, f"{report_filename}.htm")) or \
              os.path.exists(os.path.join(report_folder, f"{report_filename}.ini")):
            report_filename = f"{base_name}_{counter:03d}"
            counter += 1

        params['Report'] = report_filename
        params['ReplaceReport'] = 1
        self.report_path = os.path.join(report_folder, f"{report_filename}.htm")
        self._output_folder = report_folder
        self._report_name = report_filename

        ini_path = os.path.join(report_folder, f"{report_filename}.ini")
        try:
            config_path = self.tester.create_config(params, ini_path)
            self._update_status(f"{self.tr['config_saved']} {os.path.basename(config_path)}", "yellow")
        except (OSError, IOError) as e:
            messagebox.showerror(self.tr["error"], f"{self.tr['failed_create_config']} {e}")
            return

        self.btn_run.configure(state="disabled", text=self.tr["running"])
        self._update_status(self.tr["backtest_running"], "yellow")
        thread = threading.Thread(target=self._run_backtest_thread, args=(config_path, report_folder, report_filename), daemon=True)
        thread.start()

    def _gather_params(self):
        params = {}
        for k, v in self.entries.items():
            val = v.get().strip()
            params[k] = int(val) if val.isdigit() else val

        for k, v in self.dropdowns.items():
            val = v.get().strip()
            if " - " in val:
                params[k] = int(val.split(" - ")[0])
            else:
                params[k] = int(val) if val.isdigit() else 0

        params['Optimization'] = 0

        inputs = {}
        for k, v in self.input_entries.items():
            val = v.get().strip()
            try:
                inputs[k] = float(val) if '.' in val else int(val)
            except ValueError:
                inputs[k] = val
        params['Inputs'] = inputs
        return params

    def _run_backtest_thread(self, config_path, output_folder, report_name):
        success = self.tester.run_backtest(config_path, output_folder=output_folder, report_name=report_name)
        self.after(0, lambda: self._on_finished(success))

    def _on_finished(self, success):
        self.btn_run.configure(state="normal", text=self.tr["run_backtest"])

        if success:
            self._update_status(self.tr["generating_report"], "yellow")
            dark_report_path = None
            mt5_report = self._find_mt5_report()

            if mt5_report:
                try:
                    dark_report_name = f"{self._report_name}_dark.html"
                    dark_report_path = os.path.join(self._output_folder, dark_report_name)
                    generate_report(mt5_report, dark_report_path)
                    self._update_status(self.tr["report_generated"], "green")

                    original_in_output = os.path.join(self._output_folder, f"{self._report_name}.htm")
                    if os.path.exists(original_in_output):
                        try:
                            os.remove(original_in_output)
                        except OSError:
                            pass
                except Exception as e:  # pylint: disable=broad-except
                    self._update_status(f"{self.tr['report_gen_failed']} {e}", "red")
                    dark_report_path = mt5_report
            else:
                self._update_status(self.tr["mt5_report_not_found"], "red")

            final_report = dark_report_path or self.report_path
            CustomPopup(self, final_report, self.tr)
        else:
            self._update_status(self.tr["backtest_failed"], "red")
            messagebox.showerror(self.tr["error"], f"{self.tr['backtest_failed']}\n{self.tr['check_mt5_logs']}")

    def _find_mt5_report(self) -> str:
        possible_paths = [
            os.path.join(self.tester.data_path, f"{self._report_name}.htm"),
            os.path.join(self._output_folder, f"{self._report_name}.htm"),
            os.path.join(self.tester.data_path, "MQL5", "Files", f"{self._report_name}.htm"),
        ]
        for path in possible_paths:
            if os.path.exists(path):
                return path
        return ""


class CustomPopup(ctk.CTkToplevel):
    """Popup window shown after backtest completion."""

    def __init__(self, parent, report_path, tr):
        super().__init__(parent)
        self.tr = tr
        self.title(tr["backtest_finished"])
        self.geometry("400x200")
        self.report_path = report_path
        self.transient(parent)
        self.grab_set()

        ctk.CTkLabel(self, text=tr["backtest_completed"], font=("Arial", 16)).pack(pady=20)
        ctk.CTkLabel(self, text=f"{tr['report_saved_to']}\n{os.path.basename(report_path)}", text_color="gray").pack(pady=5)
        ctk.CTkButton(self, text=tr["open_report"], command=self.open_report, fg_color="green").pack(pady=10)
        ctk.CTkButton(self, text=tr["close"], command=self.destroy, fg_color="gray").pack(pady=5)

    def open_report(self):
        """Open the generated report file in the default browser."""
        if os.path.exists(self.report_path):
            os.startfile(self.report_path)
        else:
            folder = os.path.dirname(self.report_path)
            if os.path.exists(folder):
                os.startfile(folder)
            else:
                messagebox.showerror(self.tr["error"], self.tr["report_not_found"])


if __name__ == "__main__":
    app = MT5TesterApp()
    app.mainloop()
